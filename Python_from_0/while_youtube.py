#1 примененение цикла while - счетчик 
counter = 1                           #создаем счетчик

while counter <= 5:                   #условия цикла - пока счетчик меньше или = 5
    print(f"Counter is {counter}")    #выводим через ф-строку значение счетчика
    counter += 1                      #добавляем 1 используя синтаксический сахар
                                      #в выводе будут числа от 1 до 5


#--------------------------------------------------------

#2 список - удаление из списка элементов

my_list = [0,1,2]                     #не пустой список

while my_list:                        #пока список = True
    element = my_list.pop()           #присваиваем в переменную и с помощью метода списков удаляем элемент
    print(f" element: {element}")     #выводим результат на экран (удалять будет с конца)

 
print(my_list)                        #проверка списка - он пуст = False


#--------------------------------------------------------

#цикл while можно сделать бесконечным

# while True:
#     print("Infinite loop!")          #будет выводиться на экран бесконечно 

#--------------------------------------------------------

#бесконечный цикл но с остановкой пользователем 

# while True: 
#     pass                           #запускаем цикл
    # answer = input("Enter a number: ") #присваем в переменную инпут пользователем
    # if answer == "quit":               #если пользователь ввел стоп-слово
    #     break                          #цикл завершается, если нет, то будет запрашивать бесконечно
    # print(f"You entered: {answer}")    #то будет выводить и запрашивать бесконечно

#--------------------------------------------------------

#симуляция игры по стратегии мартингейл - кидание монетки

import random                        #импортируем модуль - ПИШУТСЯ В НАЧАЛЕ ФАЙЛА 


HEADS = "heads"                      #создаем константу РЕШКА
TAILS = "tails"                      #создаем константу ОРЕЛ
COINT_VALUES = [HEADS, TAILS]        #создаем константу со списком ОРЕЛ И РЕШКА 

def flip_coin():                     #создаем функцию - бросок монетки 
    return random.choice(COINT_VALUES)  #возвращаем из модуля функцию, которая возвращает случайные элементы списка и передаем туда наш список


# print(flip_coin())                 #проверка 

#starting_funds - страртовые средства, min_bet - минимальная ставка, max_bet - максимальная ставка 

def play_martingale(*, starting_funds: int, min_bet: int, max_bet: int ) -> int:        #функция стратегии мартингейла вплоть до проигрыша игрока
    steps_to_loose = 0                      #кол-во шагов до поражения
    current_funds = starting_funds          #текущие средства игрока, в начале - стартовым средствам игрока 
    current_bet = min_bet                   #текущая ставка, в начале равна минимальной ставке
    
    while current_funds > 0:                #пишем цикл
        # print("==============")             #чтоб было видно каждый цикл игры
        steps_to_loose += 1                 #кол-во шагов увеличиваетя на один 
        current_funds -= current_bet        #из текущих средств вычитаем текущую ставку
        print(f"{current_funds=}, {current_bet=}")  #текущие средства и текущая ставка
        flipped_coin_value = flip_coin()    #кидаем монетку используя предыдущую функцию
    
    #ДЛЯ ПРОСТОТЫ БУДЕМ СЧИТАТЬ, ЧТО ИГРОК ВСЕГДА СТАВИТ НА РЕШКУ 
        if flipped_coin_value == HEADS:     #если значение монетки равно РЕШКА
            win = current_bet *2            #фиксируем выигрыш, текущая ставка удваивается 
            # print(f"{win=}")                #размер выигрыша
            current_funds += win            #текущие средства становяться больше на размер выигрыша
            current_bet = min_bet           #текущая ставка становится равна минимальной ставке 
        else:                               #если мы ПРОИГРЫВАЕМ
            # print("loose")
            current_bet *= 2                #текущую ставку поднимаем вдвое 
            if current_bet > max_bet:       #НО если текущая ставка больше максимальной, то 
                current_bet = min_bet       #то мы сразу же откатываемся к началу и ставим минимальную ставку 
            if current_bet > current_funds: #если текущая ставка больше текущих средств пользователя ТО
                current_bet = current_funds #текущая ставка = все средства (вабанк)
    
    
    return steps_to_loose                   #возвращаем кол-во шагов до поражения 
  
# print(play_martingale(starting_funds = 100, min_bet = 1, max_bet = 100))   #запускаем указывая параметры

#запустим массово 
def simulate_martingale_for_n_players(
        *, 
        starting_funds: int, 
        min_bet: int, 
        max_bet: int, 
        n_games: int
    ) -> float:

    total_steps_to_loose = 0               #ВСЕГО шагов до проигрыша
    for i in range(n_games):               #симулируем много игр по кол-ву игроков
        step_to_lose = play_martingale(starting_funds=starting_funds, min_bet=min_bet, max_bet=max_bet)   #шаг до потери складывается из предыдущей функции
        total_steps_to_loose += step_to_lose   #ВСЕГО шагов до проигрыша из каждого
    
    return total_steps_to_loose / n_games  #возвращаем среднее значение всего шагов до проигрыша ДЕЛЕННОЕ на кол-во игр
    
print(simulate_martingale_for_n_players(n_games=10, starting_funds=100, min_bet=1, max_bet=100))#принтим
#игра не бесконечна даже при большом кол-ве денег и такой же максимальной ставке 

#--------------------------------------------------------

