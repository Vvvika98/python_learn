import string

#---------------------------------------------------------------------------------------------------------------
def squares_generator(list_of_numbers):   #написали генератор 
    for number in list_of_numbers:        #он перебирает числа в списке 
        yield number ** 2                 #функция возвращает генератор - это объект который может генерировать (в данном случае возводить в квадрат) значения по одному
        

    #пример использования генератора     
squared_numbers = squares_generator([1, 2, 3, 4])    #присваиваем в переменную функцию(генератор) с входным списком
# for square in squared_numbers:      #цикл перебирает генератор. Генератор генерирует эти числа по одному, когда цикл for их запрашивает, ОН НЕ ХРАНИТ ВЕСЬ СПИСОК В ПАМЯТИ.
#     print(square)      #Каждая строка - это отдельный вызов print(square) с разным значением square. Значение square меняется при каждой итерации цикла for.

#----------------------------------------------------------------------------------------------------------------
#1 Упражнение Генератор простых чисел

'''
Напишите генератор prime_generator(n), который выдает все простые числа, меньшие или равные n.

Что такое простое число?

Простое число - это целое число больше 1, которое делится только на 1 и само себя. Например, 2, 3, 5, 7, 11 - простые числа.


Подсказки:
1.  Вспомните, как проверить, является ли число простым.  Нужно проверить, делится ли оно на какие-либо числа от 2 до квадратного корня из этого числа.
2.  Используйте yield, чтобы выдавать найденные простые числа.
3.  Убедитесь, что ваш генератор останавливается, когда достигает n.

Это упражнение поможет вам понять, как генераторы могут лениво генерировать последовательность значений, отвечающих определенному условию.  Удачи!
'''

def prime_generator(n):             #функция prime_generator, которая принимает один аргумент: n. Это верхняя граница для поиска простых чисел. 
    for num in range(2, n+1):       #перебрала все нужные нам числа до n включительно
        # print(num)
        for i in range(2, int((num**0.5)+1)): #Нужно проверить его НА ПРОСТОТУ, делится ли оно на какие-либо числа от 2 до квадратного корня из этого числа
            # print(i)
            if num % i == 0:        #чтобы выйти из внутреннего цикла. Нет смысла продолжать проверять делители, если мы уже нашли хотя бы один.
                break
        else:                      #выполняется только в том случае, если мы проверили все числа от 2 до квадратного корня из num и не нашли ни одного делителя
            yield num              #"выдает" значение num из генератора. Когда вызывающий код запрашивает следующее значение из генератора, функция возобновляет свое выполнение с того места, где она остановилась



#либо передрать сразу в цикле 
# for prime in prime_generator(20):   #Перебирает все простые числа, сгенерированные prime_generator(20), и выводит каждое из них на экран
#     print(prime)  
# Должно вывести: 2, 3, 5, 7, 11, 13, 17, 19

#либо вызывать с помощью НЕКСТ по одному 
prime = prime_generator(20)     #Cоздает генератор prime_generator(20) и присваивает его переменной prime.
# print(next(prime))              #Затем он вызывает функцию next(prime), которая запрашивает первое значение из генератора. Функция next() возвращает следующее значение, выданное генератором, и генератор продолжает свое выполнение. Каждый последующий вызов next(prime) будет выдавать следующее простое число.

#---------------------------------------------------------------------------------------------------------------

#2 Упражнение: "Шифр Цезаря"

'''
Шифр Цезаря - это один из самых простых и известных методов шифрования. Он заключается в замене каждой буквы в тексте на букву, находящуюся на некотором фиксированном количестве позиций дальше в алфавите. Например, если сдвиг равен 3, то буква 'A' заменяется на 'D', 'B' на 'E', и так далее. Буквы в конце алфавита "заворачиваются" в начало, то есть 'X' заменяется на 'A', 'Y' на 'B', 'Z' на 'C'.

Напишите функцию caesar_cipher(text, shift), которая принимает на вход строку text (состоящую из букв английского алфавита, как строчных, так и прописных, а также пробелов и знаков препинания) и целое число shift (сдвиг). Функция должна возвращать зашифрованную строку, в которой каждая буква заменена на соответствующую букву со сдвигом, а все остальные символы (пробелы, знаки препинания) остаются без изменений.


Подсказки:

1.  Создайте строку, содержащую все буквы английского алфавита в нижнем и верхнем регистре (можно использовать string.ascii_lowercase и string.ascii_uppercase из модуля string).
2.  Для каждой буквы в тексте определите, является ли она буквой английского алфавита. Если да, то найдите ее позицию в строке алфавита, сдвиньте эту позицию на заданное значение, и замените букву на букву, находящуюся на новой позиции (не забудьте про "заворачивание" алфавита, если сдвиг выходит за его пределы).
3.  Если символ не является буквой английского алфавита, оставьте его без изменений.
4.  Собирайте зашифрованную строку посимвольно.

Дополнительные задания (для усложнения):

•   Добавьте возможность обрабатывать русские буквы.
•   Сделайте функцию регистронезависимой (чтобы строчные буквы всегда заменялись на строчные, а прописные - на прописные).
•   Сделайте так, чтобы функция игнорировала все символы, кроме букв и пробелов (то есть удаляла все знаки препинания).

Несколько важных моментов:

•   Постарайтесь разбить задачу на более мелкие подзадачи. Сначала напишите код, который просто проверяет, является ли символ буквой, затем код, который находит позицию буквы в алфавите, и так далее.
•   Тестируйте свой код на разных примерах, чтобы убедиться, что он работает правильно во всех случаях.
•   Не бойтесь экспериментировать и пробовать разные подходы.'''



def caesar_cipher(text, shift):
    #сделала импорт  string в начале файла 
    result = " "
    alphabet_1, alphabet_2 = string.ascii_lowercase, string.ascii_uppercase   #множественное присваивание в переменные импортированный алфавит в верхнем и нижнем регистрах
    alphabet = alphabet_1 + alphabet_2                      #конкатенация строк
    # for letter in alphabet:                    #перебираем в цикле буквы афавита
    # print(alphabet)
    for char in text:                            ##перебираем в заданной строке символы 
        if char in alphabet:
            result_char = alphabet.find(char) + 3
            alphabet[result_char]
        if char is not alphabet:
            char



#поверка 
text = "Hello, world!"
shift = 3
encrypted_text = caesar_cipher(text, shift)
print(encrypted_text)  # Вывод: Khoor, zruog!

text = "Khoor, zruog!"
shift = -3 # для расшифровки можно использовать отрицательный сдвиг
decrypted_text = caesar_cipher(text, shift)
print(decrypted_text) # Вывод: Hello, world!
